# 내 풀이
def solution(board, moves):
    ans  = [0]                              # 인형 바구니, 나중에 비교를 위해 [0]을 미리 담아주고 시작 어차피 값은 1 이상
    res = 0                                 # 사라진 인형 개수
    
    for m in moves:                         # [1,5,3,5,1,2,1,4]
        for b in board:                     # [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]
            if b[m-1]:                      # board안의 리스트를 돌면서 0이 아닌 값을 찾으면
                
                if ans[-1] != b[m-1]:       # ans[-1]이랑 비교, 같지 않으면 ans에 추가
                    ans.append(b[m-1])
                else:                       # ans[-1] 이랑 값이 같으면 pop, res + 2
                    ans.pop(-1)
                    res += 2
                b[m-1] = 0                  # 해당 값을 0으로 변경
                break                       # 2번째 for문을 빠져나감 / 다음 move 체크
    
    return res

'''
처음에 board가 어떻게 생겨먹은건지 모르겠어서 포기하고 다음날 맑은 정신으로 풀었당

1. board[0~5]까지 해당 원소만 다 체크 (m = 1이면 board[0][1] -> board[1][1] ...)
2. 0이 아닌 값을 만나면 ans에 추가 
3. ans[-1]이 같은 값이면(같은 인형이면) ans에서 제거하고 res + 2
4. 해당 원소를 0으로 바꿔주고 다음 move 체크

이런식으로 생각해서 최대한 간단하게 풀려고 노력했음
다른 사람 풀이가 더 어려워보여서 가져오지 않았다
''' 